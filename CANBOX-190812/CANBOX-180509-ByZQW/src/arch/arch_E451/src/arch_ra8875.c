/*
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "arch_ra8875.h"

void arch_delay_ms(int _ms);

int arch_RA8875_is_busy(void);
void arch_RA8875_Reset_setup(int onoff);
void arch_RA8875_CS_setup(int onoff);
int arch_SPI_xfer(int data);

#define RA8875_CS_0()	arch_RA8875_CS_setup(0)
#define RA8875_CS_1()	arch_RA8875_CS_setup(1)
#define SPI_ShiftByte	arch_SPI_xfer

#define SPI_WRITE_DATA	0x00
#define SPI_READ_DATA	0x40
#define SPI_WRITE_CMD	0x80
#define SPI_READ_STATUS	0xC0

#define VM_COLOR_RGB(r, g, b)	((int)(((r >> 3) << 11) | (g >> 2) << 5 | (b >> 3)))

static int s_usTouchX, s_usTouchY;	/* 触摸屏ADC值 */
static int s_WinX = 0;
static int s_WinY = 0;
static int s_WinHeight = 272;
static int s_WinWidth = 480;



/* 文字放大参数 */
enum
{
	RA_SIZE_X1 = 0,		/* 原始大小 */
	RA_SIZE_X2 = 1,		/* 放大2倍 */
	RA_SIZE_X3 = 2,		/* 放大3倍 */
	RA_SIZE_X4 = 3		/* 放大4倍 */
};

void RA8875_SetDispWin(int _usX, int _usY, int _usHeight, int _usWidth);
void RA8875_QuitWinMode(void);

static void RA8875_Delaly1us(void)
{
	int i;

	for (i = 0; i < 10; i++);	/* 延迟, 不准 */
}

static void RA8875_Delaly1ms(void)
{
	int i;

	for (i = 0; i < 5000; i++);	/* 延迟1us, 不准 */
}

static void RA8875_Delaly200us(void)
{
	int i;

	for (i = 0; i < 5000; i++);	/* 延迟1us, 不准 */
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_WriteCmd
*	功能说明: 写RA8875指令寄存器
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void RA8875_WriteCmd(int _ucRegAddr)
{
	RA8875_CS_0();
	SPI_ShiftByte(SPI_WRITE_CMD);
	SPI_ShiftByte(_ucRegAddr);
	RA8875_CS_1();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_WriteData
*	功能说明: 写RA8875指令寄存器
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void RA8875_WriteData(int _ucRegValue)
{
	RA8875_CS_0();
	SPI_ShiftByte(SPI_WRITE_DATA);
	SPI_ShiftByte(_ucRegValue);
	RA8875_CS_1();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_ReadData
*	功能说明: 读RA8875寄存器值
*	形    参: 无
*	返 回 值: 寄存器值
*********************************************************************************************************
*/
int RA8875_ReadData(int _ucRegAddr)
{
	int value;

	RA8875_CS_0();
	SPI_ShiftByte(SPI_READ_DATA);
	value = SPI_ShiftByte(0x00);
	RA8875_CS_1();

	return value;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_WriteData16
*	功能说明: 写RA8875数据总线，16bit，用于RGB显存写入
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void RA8875_WriteData16(int _usRGB)
{
	RA8875_CS_0();
	SPI_ShiftByte(SPI_WRITE_DATA);
	SPI_ShiftByte(_usRGB >> 8);
	RA8875_CS_1();

	RA8875_CS_0();
	SPI_ShiftByte(SPI_WRITE_DATA);
	SPI_ShiftByte(_usRGB);
	RA8875_CS_1();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_ReadData16
*	功能说明: 读RA8875显存，16bit RGB
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static int RA8875_ReadData16(void)
{
	int value;

	RA8875_CS_0();
	SPI_ShiftByte(SPI_READ_DATA);
	value = SPI_ShiftByte(0x00);
	RA8875_CS_1();

	return value;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_WriteReg
*	功能说明: 写RA8875寄存器. RA8875的寄存器地址和数据都是8bit的
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void RA8875_WriteReg(int _ucRegAddr, int _ucRegValue)
{
	RA8875_CS_0();
	SPI_ShiftByte(SPI_WRITE_CMD);
	SPI_ShiftByte(_ucRegAddr);
	RA8875_CS_1();

	RA8875_CS_0();
	SPI_ShiftByte(SPI_WRITE_DATA);
	SPI_ShiftByte(_ucRegValue);
	RA8875_CS_1();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_ReadReg
*	功能说明: 读RA8875寄存器. RA8875的寄存器地址和数据都是8bit的
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static int RA8875_ReadReg(int _ucRegAddr)
{
	int value;

	RA8875_CS_0();
	SPI_ShiftByte(SPI_WRITE_CMD);
	SPI_ShiftByte(_ucRegAddr);
	RA8875_CS_1();

	RA8875_CS_0();
	SPI_ShiftByte(SPI_READ_DATA);
	value = SPI_ShiftByte(0x00);
	RA8875_CS_1();

	return value;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_ReadStatus
*	功能说明: 读RA8875状态寄存器
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static int RA8875_ReadStatus(void)
{
	int value;

	RA8875_CS_0();
	SPI_ShiftByte(SPI_READ_STATUS);
	value = SPI_ShiftByte(0x00);
	RA8875_CS_1();

	return value;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_ReadID
*	功能说明: 读取LCD驱动芯片ID
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
int RA8875_ReadID(void)
{
	return RA8875_ReadReg(0x00);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetCursor
*	功能说明: 设置写显存的光标位置（图形模式）
*	形    参：_usX : X坐标; _usY: Y坐标
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_SetCursor(int _usX, int _usY)
{
	/* 设置内存写光标的坐标 【注意0x80-83 是光标图形的坐标】 */
	RA8875_WriteReg(0x46, _usX);
	RA8875_WriteReg(0x47, _usX >> 8);
	RA8875_WriteReg(0x48, _usY);
	RA8875_WriteReg(0x49, _usY >> 8);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetReadCursor
*	功能说明: 设置读显存的光标位置。 很多其他的控制器写光标和读光标是相同的寄存器，但是RA8875是不同的。
*	形    参：_usX : X坐标; _usY: Y坐标
*	返 回 值: 无
*********************************************************************************************************
*/
static void RA8875_SetReadCursor(int _usX, int _usY)
{
	/* 设置内存读光标的坐标 */
	RA8875_WriteReg(0x4A, _usX);
	RA8875_WriteReg(0x4B, _usX >> 8);
	RA8875_WriteReg(0x4C, _usY);
	RA8875_WriteReg(0x4D, _usY >> 8);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetTextCursor
*	功能说明: 设置文本写入光标位置
*	形    参：_usX : X坐标; _usY: Y坐标
*	返 回 值: 无
*********************************************************************************************************
*/
static void RA8875_SetTextCursor(int _usX, int _usY)
{
	/* 设置内存读光标的坐标 */
	RA8875_WriteReg(0x2A, _usX);
	RA8875_WriteReg(0x2B, _usX >> 8);
	RA8875_WriteReg(0x2C, _usY);
	RA8875_WriteReg(0x2D, _usY >> 8);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_Cursor_Set_Position
*	功能说明: 设置写显存的光标位置（图形模式）
*	形    参：_usX : X坐标; _usY: Y坐标
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_Cursor_Set_Position(int _usX, int _usY)
{
	/* 设置图形光标的显示坐标 */
	RA8875_WriteReg(0x80, _usX);
	RA8875_WriteReg(0x81, _usX >> 8);
	RA8875_WriteReg(0x82, _usY);
	RA8875_WriteReg(0x83, _usY >> 8);
}

/*
*********************************************************************************************************
*	函 数 名: BTE_SetTarBlock
*	功能说明: 设置RA8875 BTE目标区块以及目标图层
*	形    参:
*			int _usX : 水平起点坐标
*			int _usY : 垂直起点坐标
*			int _usHeight : 区块高度
*			int _usWidth : 区块宽度
*			int _ucLayer ： 0 图层1； 1 图层2
*	返 回 值: 无
*********************************************************************************************************
*/
void BTE_SetTarBlock(int _usX, int _usY, int _usHeight, int _usWidth, int _ucLayer)
{
	/* 设置起点坐标 */
	RA8875_WriteReg(0x58, _usX);
	RA8875_WriteReg(0x59, _usX >> 8);

	RA8875_WriteReg(0x5A, _usY);
	if (_ucLayer == 0)	/* 图层2 */
	{
		RA8875_WriteReg(0x5B, _usY >> 8);
	}
	else
	{
		RA8875_WriteReg(0x5B, (1 << 7) | (_usY >> 8));	/* Bit7 表示图层， 0 图层1； 1 图层2*/
	}

	/* 设置区块宽度 */
	RA8875_WriteReg(0x5C, _usWidth);
	RA8875_WriteReg(0x5D, _usWidth >> 8);

	/* 设置区块高度 */
	RA8875_WriteReg(0x5E, _usHeight);
	RA8875_WriteReg(0x5F, _usHeight >> 8);
}

/*
*********************************************************************************************************
*	函 数 名: BTE_SetOperateCode
*	功能说明: 设定BTE 操作码和光栅运算码
*	形    参: _ucOperate : 操作码
*	返 回 值: 无
*********************************************************************************************************
*/
void BTE_SetOperateCode(int _ucOperate)
{
	/*  设定BTE 操作码和光栅运算码  */
	RA8875_WriteReg(0x51, _ucOperate);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetFrontColor
*	功能说明: 设定前景色
*	形    参: 颜色
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_SetFrontColor(int _usColor)
{
	RA8875_WriteReg(0x63, (_usColor & 0xF800) >> 11);	/* R5  */
	RA8875_WriteReg(0x64, (_usColor & 0x07E0) >> 5);	/* G6 */
	RA8875_WriteReg(0x65, (_usColor & 0x001F));			/* B5 */
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetBackColor
*	功能说明: 设定背景色
*	形    参: 颜色
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_SetBackColor(int _usColor)
{
	RA8875_WriteReg(0x60, (_usColor & 0xF800) >> 11);	/* R5  */
	RA8875_WriteReg(0x61, (_usColor & 0x07E0) >> 5);	/* G6 */
	RA8875_WriteReg(0x62, (_usColor & 0x001F));			/* B5 */
}


/*
*********************************************************************************************************
*	函 数 名: BTE_Start
*	功能说明: 启动BTE操作
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void BTE_Start(void)
{
	RA8875_WriteCmd(0x50);	/* 设置寄存器地址 */
	RA8875_WriteData(0x80);	/* 写入寄存器值 */
}

/*
*********************************************************************************************************
*	函 数 名: BTE_Wait
*	功能说明: 等待BTE操作结束
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void BTE_Wait(void)
{
	while ((RA8875_ReadStatus() & 0x40) == 0x40);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_IsBusy
*	功能说明: RA8875是否忙
*	形    参: 无
*	返 回 值: 1 表示忙； 0 表示空闲
*********************************************************************************************************
*/
int RA8875_IsBusy(void)
{
#if 0
	if (s_ucRA8875Busy == 0)
	{
		return 0;
	}
	return 1;
#else
	return 0;
#endif
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_WaitBusy
*	功能说明: 等待RA8875空闲
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_WaitBusy(void)
{
	while ((RA8875_ReadStatus() & 0x80) == 0x80);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_Layer1Visable
*	功能说明: RA8875 图层1显示打开
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_Layer1Visable(void)
{
	/* 0x52 寄存器的 Bit2:0
		图层显示模式
		000b : 只有图层1 显示。
		001b : 只有图层2 显示。
		010b : 显示图层1 与图层2 的渐进/渐出模式。
		011b : 显示图层1 与图层2 的通透模式。
		100b : Boolean OR。
		101b : Boolean AND。
		110b : 浮动窗口模式 (Floating window mode)。
		111b :保留。
	*/
	RA8875_WriteReg(0x52, RA8875_ReadReg(0x52) & 0xF8);	/* 只有图层1 显示 */
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_Layer2Visable
*	功能说明: 只显示图层2
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_Layer2Visable(void)
{
	/* 0x52 寄存器的 Bit2:0
		图层显示模式
		000b : 只有图层1 显示。
		001b : 只有图层2 显示。
		010b : 显示图层1 与图层2 的渐进/渐出模式。
		011b : 显示图层1 与图层2 的通透模式。
		100b : Boolean OR。
		101b : Boolean AND。
		110b : 浮动窗口模式 (Floating window mode)。
		111b :保留。
	*/
	RA8875_WriteReg(0x52, (RA8875_ReadReg(0x52) & 0xF8) | 0x06);	/* 只有图层2 显示 */
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_TouchInit
*	功能说明: 初始化触摸板
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_TouchInit(void)
{
	RA8875_WriteReg(0xF0, (1 << 2));	/* 开启触控面板中断位 */


	/*
		REG[71h] Touch Panel Control Register 1 (TPCR1)

		Bit7 N/A
		Bit6 触控面板模式设定
			0 : 自动模式。
			1 : 手动模式。
		Bit5 触控面板控制器ADC 参考电压(Vref)来源设定
			0 : 内部产生参考电压。
			1 : 外部输入参考电压，ADC 参考电压准位= 1/2 VDD。
		Bit4-3 N/A
		Bit2 触控中断讯号的消除弹跳电路选择
			0: 关闭消除弹跳电路。
			1: 开启消除弹跳电路。
		Bit1-0 触控面板手动模式之选择位
			00b : 闲置模式。触控控制单元进入闲置模式。
			01b : 侦测触摸事件发生。在此模式控制器会侦测触摸事件的发
				生，事件发生可以引发中断或是由缓存器得知(REG[F1h]
				Bit2)。
			10b : X 轴数据撷取模式。在此模式触摸位置的X 轴数据会被储
				存至 REG[72h] 和REG[74h]。
			11b : Y 轴数据撷取模式。在此模式触摸位置的Y 轴数据会被储
				存至REG[73h] and REG[74h]。
	*/
	RA8875_WriteReg(0x71, (0 << 6) | (0 << 5) | (1 << 2));	/* 选择自动模式 */

	/*
		REG[70h] Touch Panel Control Register 0 (TPCR0)

		Bit7 触控面板功能设定
			0 : 关闭。
			1 : 开启。
		Bit6-4 触控面板控制器取样时间设定
			000b : ADC 取样时间为512 个系统频率周期。
			001b : ADC 取样时间为 1024 个系统频率周期。
			010b : ADC 取样时间为 2048 个系统频率周期。
			011b : ADC 取样时间为 4096 个系统频率周期。
			100b : ADC 取样时间为 8192 个系统频率周期。
			101b : ADC 取样时间为 16384 个系统频率周期。
			110b : ADC 取样时间为 32768 个系统频率周期。
			111b : ADC 取样时间为 65536 个系统频率周期。
		Bit3 触控面板唤醒模式
			0 : 关闭触控事件唤醒模式。
			1 : 触控事件可唤醒睡眠模式。
		Bit2-0 触控面板控制器ADC 频率设定
			000b : 系统频率。
			001b : 系统频率 / 2。
			010b : 系统频率 / 4。
			011b : 系统频率 / 8。
			100b : 系统频率 / 16。
			101b : 系统频率 / 32。
			110b : 系统频率 / 64。
			111b : 系统频率 / 128。

		注 : ADC 的输入频率设定不能超过10MHz。
	*/
	RA8875_WriteReg(0x70, (1 << 7) | (2 << 4) | (0 << 3) | (3 << 0));	/* 开启触摸功能； */
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_TouchPress
*	功能说明: 读取触摸事件状态
*	形    参: 无
*	返 回 值: 1 表示按下； 0 表示空闲
*********************************************************************************************************
*/
int RA8875_TouchPress(void)
{
	return (RA8875_ReadReg(0xF1) & (1 << 2));
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_TouchReadX
*	功能说明: 读取X位置ADC
*	形    参: 无
*	返 回 值: ADC值，10Bit
*********************************************************************************************************
*/
int RA8875_TouchReadX(void)
{
	int usAdc;
	int ucReg74;

	/* 软件读取中断事件标志 */
	if (RA8875_ReadReg(0xF1) & (1 << 2))
	{
		ucReg74 = RA8875_ReadReg(0x74);
		usAdc = RA8875_ReadReg(0x72);	/* Bit9-2 */
		usAdc <<= 2;
		usAdc += (ucReg74 & 0x03);

		s_usTouchX = usAdc;

		usAdc = RA8875_ReadReg(0x73);	/* Bit9-2 */
		usAdc <<= 2;
		usAdc += ((ucReg74 & 0x0C) >> 2);

		s_usTouchY = usAdc;
	}
	else
	{
		s_usTouchX = 0;
		s_usTouchY = 0;
	}

	/*
		bit2 写入功能?? 触控面板中断清除位
		0 : 未操作。
		1 : 清除触控面板中断。
		读取功能?? 触控面板中断状态
		0 : 未发生触控面板中断。
		1 : 发生触控面板中断。
	*/

	/*
		不要调用这个函数写寄存器，因为该函数改写了busy标志
		RA8875_WriteReg(0xF1, (1 << 2));	 必须清除， 才会下次采样.
	*/
	if(s_usTouchY) {
	RA8875_WriteCmd(0xF1);
	RA8875_WriteData(1 << 2);

	RA8875_Delaly200us();
	}

	return s_usTouchX;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_TouchReadY
*	功能说明: 读取Y位置ADC
*	形    参: 无
*	返 回 值: ADC值，10Bit
*********************************************************************************************************
*/
int RA8875_TouchReadY(void)
{
	return s_usTouchY;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_TouchReadXY
*	功能说明: 读取XY位置ADC
*	形    参: *_usX: X坐标ADC10Bit值; *_usY: Y坐标ADC10Bit值
*	返 回 值: 无
*********************************************************************************************************
*/
int RA8875_TouchReadXY(int *_usX, int *_usY)
{
	int usAdc;
	int ucReg74;
	int __try_ = 3;

again:
	/* 软件读取中断事件标志 */
	if (RA8875_ReadReg(0xF1) & (1 << 2))
	{
		ucReg74 = RA8875_ReadReg(0x74);
		usAdc = RA8875_ReadReg(0x72);	/* Bit9-2 */
		usAdc <<= 2;
		usAdc += (ucReg74 & 0x03);

		if(_usX)
			*_usX = usAdc;

		usAdc = RA8875_ReadReg(0x73);	/* Bit9-2 */
		usAdc <<= 2;
		usAdc += ((ucReg74 & 0x0C) >> 2);

		if(_usY)
			*_usY = usAdc;

		/*
			bit2 写入功能?? 触控面板中断清除位
			0 : 未操作。
			1 : 清除触控面板中断。
			读取功能?? 触控面板中断状态
			0 : 未发生触控面板中断。
			1 : 发生触控面板中断。
		*/
		/* 必须清除， 才会下次采样. */
		RA8875_WriteReg(0xF1, (1 << 2));

		RA8875_Delaly200us();

		return 1;
	}
	if(--__try_ > 0) {
		goto again;
	}

	return 0;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DispOn
*	功能说明: 打开显示
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DispOn(void)
{
	RA8875_WriteReg(0x01, 0x80);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DispOff
*	功能说明: 关闭显示
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DispOff(void)
{
	RA8875_WriteReg(0x01, 0x00);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_PutPixel
*	功能说明: 画1个像素
*	形    参：
*			_usX,_usY : 像素坐标
*			_usColor  ：像素颜色
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_PutPixel(int _usX, int _usY, int _usColor)
{
	RA8875_SetCursor(_usX, _usY);	/* 设置光标位置 */

	RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
	RA8875_WriteData16(_usColor);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_GetPixel
*	功能说明: 读取1个像素
*	形    参：
*			_usX,_usY : 像素坐标
*			_usColor  ：像素颜色
*	返 回 值: RGB颜色值
*********************************************************************************************************
*/
int RA8875_GetPixel(int _usX, int _usY)
{
	int usRGB;

	RA8875_SetReadCursor(_usX, _usY);	/* 设置读取光标位置 */

	RA8875_WriteCmd(0x02);

	usRGB = RA8875_ReadData16();

	return usRGB;

}

/*
*********************************************************************************************************
*	函 数 名: RA8875_ClrScr
*	功能说明: 根据输入的颜色值清屏.RA8875支持硬件单色填充。该函数仅对当前激活的显示窗口进行清屏. 显示
*			 窗口的位置和大小由 RA8875_SetDispWin() 函数进行设置
*	形    参：_usColor : 背景色
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_ClrScr(int _usColor)
{
	/* 也可以通过0x30-0x37寄存器获得获得当前激活的显示窗口 */

	/* 单色填满功能, 中文pdf 第162页
	此功能使用于将选定特定区域画面清除或是\入给定某种前景色，R8875 填入的单色设定为BTE 前景色。

	操作步骤：
		1. 设定目的图层和位置 REG[58h], [59h], [5Ah], [5Bh]
		2. 设定BTE 宽度和高度 REG[5Ch], [5Dh], [5Eh], [5Fh]
		3. 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch
		4. 设定前景色  REG[63h], [64h], [65h]
		5. 开启BTE 功能  REG[50h] Bit7 = 1
		6. 检查状态缓存器 STSR Bit6，确认BTE 是否完成
	*/
	BTE_SetTarBlock(s_WinX, s_WinY, s_WinHeight, s_WinWidth, 0);	/* 设置BTE位置和宽度高度以及目标图层（0或1） */
	BTE_SetOperateCode(0x0C);		/* 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch */
	RA8875_SetFrontColor(_usColor);	/* 设置BTE前景色 */
	BTE_Start();					/* 开启BTE 功能 */
	BTE_Wait();						/* 等待操作结束 */
}

/*局部上色*/
void RA8875_PartClrScr(int x,int y,int w,int h,int _usColor)
{
	/* 也可以通过0x30-0x37寄存器获得获得当前激活的显示窗口 */

	/* 单色填满功能, 中文pdf 第162页
	此功能使用于将选定特定区域画面清除或是\入给定某种前景色，R8875 填入的单色设定为BTE 前景色。

	操作步骤：
		1. 设定目的图层和位置 REG[58h], [59h], [5Ah], [5Bh]
		2. 设定BTE 宽度和高度 REG[5Ch], [5Dh], [5Eh], [5Fh]
		3. 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch
		4. 设定前景色  REG[63h], [64h], [65h]
		5. 开启BTE 功能  REG[50h] Bit7 = 1
		6. 检查状态缓存器 STSR Bit6，确认BTE 是否完成
	*/
	BTE_SetTarBlock(x, y, h, w, 0);	/* 设置BTE位置和宽度高度以及目标图层（0或1） */
	BTE_SetOperateCode(0x0C);		/* 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch */
	RA8875_SetFrontColor(_usColor);	/* 设置BTE前景色 */
	BTE_Start();					/* 开启BTE 功能 */
	BTE_Wait();						/* 等待操作结束 */
}
/*
*********************************************************************************************************
*	函 数 名: LCD8875_DrawHLine
*	功能说明: 主要用于UCGUI的接口函数			  
*	形    参：_usX1    ：起始点X坐标
			  _usY1    ：起始点Y坐标
			  _usX2    ：结束点X坐标
			  _usColor : 背景色
*	返 回 值: 无
*********************************************************************************************************
*/
void LCD8875_DrawHLine(int _usX1 , int _usY1 , int _usX2 , int _usColor)
{
}

/*
*********************************************************************************************************
*	函 数 名: LCD8875_DrawVLine
*	功能说明: 主要用于UCGUI的接口函数			  
*	形    参：_usX1    ：起始点X坐标
			  _usY1    ：起始点Y坐标
			  _usY2    ：结束点Y坐标
			  _usColor : 背景色
*	返 回 值: 无
*********************************************************************************************************
*/
void LCD8875_DrawVLine(int _usX1 , int _usY1 , int _usY2 , int _usColor)
{
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DrawBMP
*	功能说明: 在LCD上显示一个BMP位图，位图点阵扫描次序：从左到右，从上到下
*	形    参：
*			_usX, _usY : 图片的坐标
*			_usHeight  ：图片高度
*			_usWidth   ：图片宽度
*			_ptr       ：图片点阵指针
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DrawBMP(int _usX, int _usY, int _usHeight, int _usWidth, int *_ptr)
{
	unsigned long index = 0;
	const int *p;

	/* 设置图片的位置和大小， 即设置显示窗口 */
	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);

	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */

	p = _ptr;
	for (index = 0; index < _usHeight * _usWidth; index++)
	{
		/*
			armfly : 进行优化, 函数就地展开
			RA8875_WriteRAM(_ptr[index]);

			此处可考虑用DMA操作
		*/
		RA8875_WriteData16(*p++);
	}

	/* 退出窗口绘图模式 */
	RA8875_QuitWinMode();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DrawLine
*	功能说明: 采用RA8875的硬件功能，在2点间画一条直线。
*	形    参：
*			_usX1, _usY1 ：起始点坐标
*			_usX2, _usY2 ：终止点Y坐标
*			_usColor     ：颜色
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DrawLine(int _usX1 , int _usY1 , int _usX2 , int _usY2 , int _usColor, int mode)
{
	/* pdf 第131页
		RA8875 支持直线绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画直线。先设
		定直线的起始点REG[91h~94h] 与结束点REG[95h~98h]，直线的颜色REG[63h~65h]，然后启
		动绘图设定REG[90h] Bit4 = 0, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将直线的图形写入
		DDRAM，相对的在TFT 模块上就可以显示所画的直线。
	*/

	/* 设置起点坐标 */
	RA8875_WriteReg(0x91, _usX1);
	RA8875_WriteReg(0x92, _usX1 >> 8);
	RA8875_WriteReg(0x93, _usY1);
	RA8875_WriteReg(0x94, _usY1 >> 8);

	/* 设置终点坐标 */
	RA8875_WriteReg(0x95, _usX2);
	RA8875_WriteReg(0x96, _usX2 >> 8);
	RA8875_WriteReg(0x97, _usY2);
	RA8875_WriteReg(0x98, _usY2 >> 8);

	RA8875_SetFrontColor(_usColor);	/* 设置直线的颜色 */

	RA8875_WriteReg(0x90, (1 << 7) | (0 << 4) | (0 << 0));	/* 开始画直线 */
	//while (RA8875_ReadReg(0x90) & (1 << 7));				/* 等待结束 */
	RA8875_WaitBusy();
}

/*
 * 画三角形第三个点
*			mode：0x80 填充模式
 */
void RA8875_DrawTriangle(int _usX1 , int _usY1 , int _usX2 , int _usY2 ,int _usX3, int _usY3, int _usColor, int mode)
{
	RA8875_WriteReg(0x91, _usX1);
	RA8875_WriteReg(0x92, _usX1 >> 8);
	RA8875_WriteReg(0x93, _usY1);
	RA8875_WriteReg(0x94, _usY1 >> 8);

	RA8875_WriteReg(0x95, _usX2);
	RA8875_WriteReg(0x96, _usX2 >> 8);
	RA8875_WriteReg(0x97, _usY2);
	RA8875_WriteReg(0x98, _usY2 >> 8);

	RA8875_WriteReg(0xA9, _usX3);
	RA8875_WriteReg(0xAA, _usX3 >> 8);
	RA8875_WriteReg(0xAB, _usY3);
	RA8875_WriteReg(0xAC, _usY3 >> 8);

	RA8875_SetFrontColor(_usColor);	/* 设置直线的颜色 */

	if(mode & 0x80)
		RA8875_WriteReg(0X90,0XA1);
	else
		RA8875_WriteReg(0X90,0X81);
	RA8875_WaitBusy();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DrawRect
*	功能说明: 采用RA8875硬件功能绘制矩形
*	形    参：
*			_usX,_usY：矩形左上角的坐标
*			_usHeight ：矩形的高度
*			_usWidth  ：矩形的宽度
*			_usColor  ：颜色
*			mode：0x80 填充模式
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DrawRect(int _usX, int _usY, int _usHeight, int _usWidth, int _usColor, int mode)
{
	/*
		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
	实心方形 (Fill)

	 ---------------->---
	|(_usX，_usY)        |
	V                    V  _usHeight
	|                    |
	 ---------------->---
		  _usWidth
	*/

	/* 设置起点坐标 */
	RA8875_WriteReg(0x91, _usX);
	RA8875_WriteReg(0x92, _usX >> 8);
	RA8875_WriteReg(0x93, _usY);
	RA8875_WriteReg(0x94, _usY >> 8);

	/* 设置终点坐标 */
	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);

	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */

	if(mode & 0x80) 
		RA8875_WriteReg(0x90, (1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));	/* 开始填充矩形  */
	else
		RA8875_WriteReg(0x90, (1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));	/* 开始画矩形  */
//	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
	RA8875_WaitBusy();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DrawCircle
*	功能说明: 绘制一个圆，笔宽为1个像素
*	形    参：
*			_usX,_usY  ：圆心的坐标
*			_usRadius  ：圆的半径
*			_usColor  ：颜色
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DrawCircle(int _usX, int _usY, int _usRadius, int _usColor, int mode)
{
	/*
		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
		画出空心圆 (Not Fill
	*/
	/* 设置圆的半径 */
	if (_usRadius > 255)
	{
		return;
	}

	/* 设置圆心坐标 */
	RA8875_WriteReg(0x99, _usX);
	RA8875_WriteReg(0x9A, _usX >> 8);
	RA8875_WriteReg(0x9B, _usY);
	RA8875_WriteReg(0x9C, _usY >> 8);

	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */

	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */

	if(mode & 0x80) 
		RA8875_WriteReg(0x90, (1 << 6) | (1 << 5));				/* 开始画圆, 填充  */
	else
		RA8875_WriteReg(0x90, (1 << 6) | (0 << 5));				/* 开始画圆, 不填充  */
	RA8875_WaitBusy();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DrawEllipse
*	功能说明: 绘制一个椭圆，笔宽为1个像素
*	形    参：
*			_usX,_usY  ：椭圆圆心的坐标
*			_usSRadius  ：椭圆的短轴半径
*			_usLRadius  ：椭圆的长轴半径
*			_usColor  ：颜色
*	返 回 值: 无
*********************************************************************************************************
*/
void  RA8875_DrawEllipse(int _usX, int _usY, int _usSRadius, int _usLRadius, int _usColor)
{
	RA8875_WriteReg(0xA5, _usX);
	RA8875_WriteReg(0xA6, _usX >> 8);
	RA8875_WriteReg(0xA7, _usY);
	RA8875_WriteReg(0xA8, _usY >> 8);

	RA8875_WriteReg(0xA1, _usSRadius);
	RA8875_WriteReg(0xA2, _usSRadius >> 8);
	RA8875_WriteReg(0xA3, _usLRadius);
	RA8875_WriteReg(0xA4, _usLRadius >> 8);

	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
	RA8875_WaitBusy();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_Drawcurve
*	功能说明: 绘制曲线
*	形    参：
*			_usX,_usY  ：椭圆圆心的坐标
*			_usSRadius  ：椭圆的短轴半径
*			_usLRadius  ：椭圆的长轴半径
*			_usColor  ：颜色
*			Fill_mode	:	填充模式：0（填充）1（无填充）
*			direction：方向，1（第一象限）2（第二象限）3（第三象限）4（第四象限）
*	返 回 值: 无
*********************************************************************************************************
*/
void  RA8875_Drawcurve(int _usX, int _usY, int _usSRadius, int _usLRadius, int _usColor,int Fill_mode,int direction)
{
	int mod=0x10;
	RA8875_WriteReg(0xA5, _usX);
	RA8875_WriteReg(0xA6, _usX >> 8);
	RA8875_WriteReg(0xA7, _usY);
	RA8875_WriteReg(0xA8, _usY >> 8);

	RA8875_WriteReg(0xA1, _usSRadius);
	RA8875_WriteReg(0xA2, _usSRadius >> 8);
	RA8875_WriteReg(0xA3, _usLRadius);
	RA8875_WriteReg(0xA4, _usLRadius >> 8);
	
	if(Fill_mode)
		mod |= 0x80;
	else
		mod |= 0xc0;
	if(direction==1)
		mod |= 0x01;
	else if(direction==2)
		mod |= 0x02;
	else if(direction==3)
		mod &= 0xfc;
	else
		mod |=0x03;
	
	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
	RA8875_WriteReg(0xA0, mod);
	
	RA8875_WaitBusy();
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_rounded_rectangle
*	功能说明:	圆角方框
*	形    参：
*			_usX,_usY  ：椭圆圆心的坐标
*			_usSRadius  ：椭圆的短轴半径
*			_usLRadius  ：椭圆的长轴半径
*			_usColor  ：颜色
*			Fill_mode	:	填充模式：1（填充）0（无填充）
*			direction：方向，1（第一象限）2（第二象限）3（第三象限）4（第四象限）
*	返 回 值: 无
*********************************************************************************************************
*/
void  RA8875_rounded_rectangle(int x1, int y1, int x2, int y2, int _usColor,int r1,int r2,int mode)
{
	RA8875_WriteReg(0x91, x1);
	RA8875_WriteReg(0x92, x1 >> 8);
	RA8875_WriteReg(0x93, y1);
	RA8875_WriteReg(0x94, y1 >> 8);

	RA8875_WriteReg(0x95, x2);
	RA8875_WriteReg(0x96, x2 >> 8);
	RA8875_WriteReg(0x97, y2);
	RA8875_WriteReg(0x98, y2 >> 8);
	
	RA8875_WriteReg(0xa1, r1);
	RA8875_WriteReg(0xa2, r1 >> 8);
	RA8875_WriteReg(0xa3, r2);
	RA8875_WriteReg(0xa4, r2 >> 8);
	
	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
	
	
	if(mode==0)
		RA8875_WriteReg(0xa0, (1<<5)|(0<<6)|(1<<7));
	else
		RA8875_WriteReg(0xa0, (1<<5)|(1<<6)|(1<<7));
	RA8875_WaitBusy();
}



/*
*********************************************************************************************************
*	函 数 名: RA8875_SetFont
*	功能说明: 文本模式，设置文字字体、行距和字距
*	形    参：
*			_ucFontType : 字体类型: RA_FONT_16, RA_FONT_24, RA_FONT_32
*			_ucLineSpace : 行距，像素单位 (0-31)
*			_ucCharSpace : 字距，像素单位 (0-63)
*
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_SetFont(int _ucFontType, int _ucLineSpace, int _ucCharSpace)
{
	/*
		[29H]在文字模式下，用来设定文字间的行距 (单位: 像素) 。
		只有低5个bit有效，0-31
	*/
	if (_ucLineSpace >31)
	{
		_ucLineSpace = 31;
	}
	RA8875_WriteReg(0x29, _ucLineSpace);

	/*
		[2EH] 设置字符间距（像素单位，0-63），和字体（16*16，24*24，32*32）
	*/
	if (_ucCharSpace > 63)
	{
		_ucCharSpace = 63;
	}
	if (_ucFontType > RA_FONT_32)
	{
		_ucFontType = RA_FONT_16;
	}
	RA8875_WriteReg(0x2E, (_ucCharSpace & 0x3F) | (_ucFontType << 6));
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetFontZoom
*	功能说明: 文本模式，设置文字的放大模式，1X,2X,3X, 4X
*	形    参：
*			_ucHSize : 文字水平放大倍数，0-3 分别对应 X1、X2、X3、X4
*			_ucVSize : 文字处置放大倍数，0-3 分别对应 X1、X2、X3、X4
*		建议输入参数用枚举：RA_SIZE_X1、RA_SIZE_X2、RA_SIZE_X3、RA_SIZE_X4
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_SetTextZoom(int _ucHSize, int _ucVSize)
{
	/*
		pdf 第22页		[22H]
		bit7 用于对齐，一般不用，缺省设0
		bit6 用于通透，一般不用，缺省设0
		bit4 用于旋转90读，一般不用，缺省设0
		bit3-2 水平放大倍数
		bit1-0 垂直放大倍数
	*/
	RA8875_WriteReg(0x22, ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DispAscii
*	功能说明: 显示ASCII字符串，字符点阵来自于RA8875内部ROM中的ASCII字符点阵（8*16），不支持汉字.
*			文字颜色、背景颜色、是否通透由其他的函数进行设置
*			void RA8875_SetFrontColor(int _usColor);
*			void RA8875_SetBackColor(int _usColor);
*	形    参：_usX, _usY : 显示位置（坐标）
*			 _ptr : AascII字符串，已0结束
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DispAscii(int _usX, int _usY, char *_ptr)
{
	/*
		RA8875 内建8x16 点的ASCII 字型ROM，提供使用者更方便的方式用特定编码 (Code) 输入文
		字。内建的字集支持ISO/IEC 8859-1~4 编码标准，此外，使用者可以透过REG[60h~62h] 选择
		文字前景颜色，以及透过REG[63h~65h] 选择背景颜色.

		ISO/IEC 8859-1，又称Latin-1或“西欧语言”，是国际标准化组织内ISO/IEC 8859的第一个8位字符集。
		它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。

		ISO/IEC 8859-2 Latin-2或“中欧语言”，是国际标准化组织内ISO/IEC 8859的其中一个8位字符集 .
		ISO/IEC 8859-3 南欧语言字符集
		ISO/IEC 8859-4 北欧语言字符集
	*/

	/*
	(1) Text mode  REG[40h] bit7=1
	(2) Internal Font ROM Select   REG[21h] bit7=0, bit5=0
	(3) Font foreground and background color Select  REG[63h~65h], REG[60h~62h]
	(4) Write the font Code  CMD_WR[02h]    DATA_WR[font_code]
	*/

	RA8875_SetTextCursor(_usX, _usY);

	RA8875_WriteReg(0x40, (1 << 7));	/* 设置为文本模式 */

	/* 选择CGROM font; 选择内部CGROM; 内部CGROM 编码选择ISO/IEC 8859-1. */
	RA8875_WriteReg(0x2F, 0x00);
	RA8875_WriteReg(0x21, (0 << 7) | (0 << 5) | (0 << 1) | (0 << 0));

	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */

	/* 开始循环处理字符 */
	while (*_ptr != 0)
	{
		RA8875_WriteData(*_ptr);
		while ((RA8875_ReadStatus() & 0x80) == 0x80);	/* 必须等待内部写屏操作完成 */
		_ptr++;
	}

	RA8875_WriteReg(0x40, (0 << 7));	/* 还原为图形模式 */
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_DispStr
*	功能说明: 显示字符串，字符点阵来自于RA8875外接的字库芯片，支持汉字.
*			文字颜色、背景颜色、是否通透由其他的函数进行设置
*			void RA8875_SetFrontColor(int _usColor);
*			void RA8875_SetBackColor(int _usColor);
*	形    参：_usX, _usY : 显示位置（坐标）
*			 _ptr : AascII字符串，已0结束
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_DispStr(int _usX, int _usY, char *_ptr)
{
	/*
		RA8875 透过使用 ― 上海集通公司 (Genitop Inc) 外部串行式字体内存 (Font ROM)，可支持各样
		的文字写入到DDRAM 中。RA8875 与上海集通公司 (Genitop Inc) 兼容的产品包含 :
		GT21L16TW/GT21H16T1W 、GT23L16U2W 、GT23L24T3Y/GT23H24T3Y 、GT23L24M1Z 、
		及 GT23L32S4W/GT23H32S4W。这些字体包含16x16, 24x24, 32x32 点 (Dot) 与不同的字

		安富莱RA8875驱动板集成的字库芯片为 集通字库芯片_GT23l32S4W

		GT23L32S4W是一款内含11X12点阵、15X16点、24X24点阵、32X32点阵的汉字库芯片，支持GB2312
		国标汉字（含有国家信标委合法授权）及SCII字符。排列格式为横置横排。用户通过字符内码，利用本手
		册提供的方法计算出该字符点阵在芯片中的地址，可从该地址连续读出字符点阵信息。
	*/

	/* 设置文本显示位置，注意文本模式的写入光标和图形模式的写入光标是不同的寄存器 */
	RA8875_SetTextCursor(_usX, _usY);

	RA8875_WriteReg(0x40, (1 << 7));	/* 设置为文本模式 */

	/*
		Serial Flash/ROM 频率频率设定
			0xb: SFCL 频率 = 系统频率频率(当DMA 为致能状态，并且色彩深度为256 色，则SFCL 频率
				固定为=系统频率频率/ 2)
			10b: SFCL 频率 =系统频率频率/ 2
			11b: SFCL 频率 =系统频率频率/ 4

		安富莱驱动板系统频率为 68MHz

		GT23L32S4W的访问速度：SPI 时钟频率：20MHz(max.)

		因此需要设置 4 分频, 17MHz
	*/
	RA8875_WriteReg(0x06, (1 << 1));	/* 设置为文本模式 */

	/* 选择外部字体ROM */
	RA8875_WriteReg(0x21, (0 << 7) | (1 << 5));

	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
		7	Serial Flash/ROM I/F # 选择
				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板字库芯片接在 0 接口]
				1:选择Serial Flash/ROM 1 接口。
		6	Serial Flash/ROM 寻址模式
				0: 24 位寻址模式。
				此位必须设为0。
		5	Serial Flash/ROM 波形模式
				0: 波形模式 0。
				1: 波形模式 3。
		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
			01b: 5 bus ??1 byte 空周期。
			1Xb: 6 bus ??2 byte 空周期。
		2	Serial Flash /ROM 存取模式 (Access Mode)
			0: 字型模式 。
			1: DMA 模式。
		1-0	Serial Flash /ROM I/F Data Latch 选择模式
			0Xb: 单一模式。
			10b: 双倍模式0。
			11b: 双倍模式1。
	*/
	RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (1 << 3) | (0 << 2) | (0 << 1));

	/*
		设置外部字体芯片型号为 GT23L32S4W, 编码为GB2312,

		Bit1:0 决定ASCII字符的格式：
			0 = NORMAL		 [笔画细, 和汉字顶部对齐]
			1 = Arial		 [笔画粗，和汉字底部对齐]
			2 = Roman		 [笔画细, 和汉字底部对齐]
			3 = Bold		 [乱码,不可用]
	 */
	RA8875_WriteReg(0x2F, (4 << 5) | (0 << 2) | (1 << 0));

	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */

	/* 开始循环处理字符 */
	while (*_ptr != 0)
	{
		RA8875_WriteData(*_ptr);
		while ((RA8875_ReadStatus() & 0x80) == 0x80);
		_ptr++;
	}

	RA8875_WriteReg(0x40, (0 << 7));	/* 还原为图形模式 */
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetDispWin
*	功能说明: 设置显示窗口，进入窗口显示模式。在窗口显示模式，连续写显存，光标会自动在设定窗口内进行递增
*	形    参：
*		_usX : 水平坐标
*		_usY : 垂直坐标
*		_usHeight: 窗口高度
*		_usWidth : 窗口宽度
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_SetDispWin(int _usX, int _usY, int _usHeight, int _usWidth)
{

	int usTemp;

	/* 坐标系统示意图： （横屏）
			 -----------------------------
			|(0,0)                        |
			|     --------->              |
			|         |                   |
			|         |                   |
			|         |                   |
			|         V                   |
			|     --------->              |
			|                    (479,271)|
			 -----------------------------

		左上角是坐标零点, 扫描方向，先从左到右，再从上到下。

		如果需要做竖屏方式，你需要进行物理坐标和逻辑坐标的转换
	*/

	RA8875_WriteReg(0x30, _usX);
	RA8875_WriteReg(0x31, _usX >> 8);

	RA8875_WriteReg(0x32, _usY);
	RA8875_WriteReg(0x33, _usY >> 8);

	usTemp = _usWidth + _usX - 1;
	RA8875_WriteReg(0x34, usTemp);
	RA8875_WriteReg(0x35, usTemp >> 8);

	usTemp = _usHeight + _usY - 1;
	RA8875_WriteReg(0x36, usTemp);
	RA8875_WriteReg(0x37, usTemp >> 8);

	RA8875_SetCursor(_usX, _usY);

	/* 保存当前窗口信息，提高以后单色填充操作的效率.
	另外一种做法是通过读取0x30-0x37寄存器获得当前窗口，不过效率较低 */
	s_WinX = _usX;
	s_WinY = _usY;
	s_WinHeight = _usHeight;
	s_WinWidth = _usWidth;
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_QuitWinMode
*	功能说明: 退出窗口显示模式，变为全屏显示模式
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_QuitWinMode(void)
{
	RA8875_SetDispWin(0, 0, s_WinHeight, s_WinWidth);
}

/*
*********************************************************************************************************
*	函 数 名: RA8875_SetBackLight
*	功能说明: 配置RA8875芯片的PWM1相关寄存器，控制LCD背光
*	形    参：_bright 亮度，0是灭，255是最亮
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_SetBackLight(int _bright)
{
	if (_bright == 0)
	{
		/* 关闭PWM, PWM1引脚缺省输出LOW  */
		RA8875_WriteReg(0x8A, 0 << 6);
	}
	else if (_bright == 255)	/* 最大亮度 */
	{
		/* 关闭PWM, PWM1引脚缺省输出HIGH */
		RA8875_WriteReg(0x8A, 1 << 6);
	}
	else
	{
		/* 使能PWM1, 进行占空比调节 */

		/* 	REG[8Ah] PWM1 Control Register (P1CR)

			Bit7 脉波宽度调变 (PWM1) 设定
				0 : 关闭，此状态下，PWM1 输出准位依照此缓存器Bit6 决定。
				1 : 开启。

			Bit6 PWM1 关闭时的准位
				0 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”Low” 状态。
				1 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”High” 状态。

			Bit5 保留

			Bit4 PWM1 功能选择
				0 : PWM1 功能。
				1 : PWM1 固定输出一频率为外部晶体振荡器Clock (Fin) 频率 1 /16 的Clock

			Bit3-0  PWM1 电路的频率来源选择PWM_CLK	【不是PWM输出频率】
				0000b : SYS_CLK / 1 1000b : SYS_CLK / 256
				0001b : SYS_CLK / 2 1001b : SYS_CLK / 512
				0010b : SYS_CLK / 4 1010b : SYS_CLK / 1024
				0011b : SYS_CLK / 8 1011b : SYS_CLK / 2048
				0100b : SYS_CLK / 16 1100b : SYS_CLK / 4096
				0101b : SYS_CLK / 32 1101b : SYS_CLK / 8192
				0110b : SYS_CLK / 64 1110b : SYS_CLK / 16384
				0111b : SYS_CLK / 128 1111b : SYS_CLK / 32768

				“SYS_CLK” 代表系统频率， 例如SYS_CLK 为20MHz， 当Bit[3:0] =0001b 时，PWM1 频率来源为10MHz。

				对于安富莱的4.3寸模块，SYS_CLK =  68.75MHz
				Bit3-0 选择8时，PWM_CLK = 68.75MHz / 256 = 0.2685546875 MHz = 268.55KHz；
				实际输出的PWM波形频率 = PWM_CLK / 256 = 1.049kHz。【用示波器已验证，PWM频率很准】

				选择10时，频率256Hz左右，避免1KHz的啸叫音
		*/

		RA8875_WriteReg(0x8A, (1 << 7) | 10);

		/* REG[8Bh] PWM1 Duty Cycle Register (P1DCR) */
		RA8875_WriteReg(0x8B, _bright);
	}
}



/*
*********************************************************************************************************
*	函 数 名: RA8875_Init
*	功能说明: 初始化RA8875驱动芯片
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void RA8875_Init()
{
	if(RA8875_ReadID() != 0x75)
		return ;

	arch_RA8875_Reset_setup(0);
	RA8875_Delaly1ms();
	arch_RA8875_Reset_setup(1);
	RA8875_Delaly1ms();

	/* 读取 RA8875 芯片额GPIX引脚的电平状态 */
	//RA8875_ReadReg(0xC7);

	/* 初始化PLL.  晶振频率为25M */
	RA8875_WriteCmd(0x88);
	RA8875_Delaly1us();		/* 延迟1us */
	RA8875_WriteData(10);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 10 */

	RA8875_Delaly1ms();

	RA8875_WriteCmd(0x89);
	RA8875_Delaly1us();		/* 延迟1us */
	RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */

	/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
	   SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
	   = 25M * (10 + 1) / ((0 + 1) * (2 ^ 2))
	   = 68.75MHz
	   */

	/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
	RA8875_Delaly1ms();

	/*
	 * 配置系统控制寄存器。 中文pdf 第18页:
	 *
	 * bit3:2 色彩深度设定 (Color Depth Setting)
	 * 00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
	 * 1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
	 * 
	 * bit1:0 MCUIF 选择
	 * 00b : 8-位MCU 接口。
	 * 1xb : 16-位MCU 接口。 【选这个】
	 */
	RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
	
	
	/* REG[04h] Pixel Clock Setting Register   PCSR
	 * bit7  PCLK Inversion
	 * 0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
	 * 1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
	 * bit1:0 PCLK 频率周期设定
	 * Pixel Clock  PCLK 频率周期设定。
	 * 00b: PCLK 频率周期= 系统频率周期。
	 * 01b: PCLK 频率周期= 2 倍的系统频率周期。
	 * 10b: PCLK 频率周期= 4 倍的系统频率周期。
	 * 11b: PCLK 频率周期= 8 倍的系统频率周期。
	 */
	RA8875_WriteReg(0x04, 0x82);    /* 设置PCLK反相 */
	RA8875_Delaly1ms();

	//Horizontal set
	//HDWR//Horizontal Display Width Setting Bit[6:0]
	//Horizontal display width(pixels) = (HDWR + 1)*8
	RA8875_WriteReg(0x14, 0x3B);
	RA8875_WriteReg(0x15, 0x00);

	//HNDR//Horizontal Non-Display Period Bit[4:0]
	//Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
	RA8875_WriteReg(0x16, 0x01);

	//HSTR//HSYNC Start Position[4:0]
	//HSYNC Start Position(PCLK) = (HSTR + 1)*8
	RA8875_WriteReg(0x17, 0x00);

	//HPWR//HSYNC Polarity ,The period width of HSYNC.
	//HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
	RA8875_WriteReg(0x18, 0x05);

	//Vertical set
	//VDHR0 //Vertical Display Height Bit [7:0]
	//Vertical pixels = VDHR + 1
	RA8875_WriteReg(0x19, 0x0F);

	//VDHR1 //Vertical Display Height Bit [8]
	//Vertical pixels = VDHR + 1
	RA8875_WriteReg(0x1A, 0x01);

	//VNDR0 //Vertical Non-Display Period Bit [7:0]
	//Vertical Non-Display area = (VNDR + 1)
	RA8875_WriteReg(0x1B, 0x02);

	//VNDR1 //Vertical Non-Display Period Bit [8]
	//Vertical Non-Display area = (VNDR + 1)
	RA8875_WriteReg(0x1C, 0x00);

	//VSTR0 //VSYNC Start Position[7:0]
	//VSYNC Start Position(PCLK) = (VSTR + 1)
	RA8875_WriteReg(0x1D, 0x07);

	//VSTR1 //VSYNC Start Position[8]
	//VSYNC Start Position(PCLK) = (VSTR + 1)
	RA8875_WriteReg(0x1E, 0x00);

	//VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
	//VSYNC Pulse Width(PCLK) = (VPWR + 1)
	RA8875_WriteReg(0x1F, 0x09);


	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
	RA8875_WriteReg(0xC7, 0x01);	/* DISP = 1 */

	/* LCD 显示/关闭讯号 (LCD Display on) */
	RA8875_WriteReg(0x01, 0x80);

	/* 	REG[40h] Memory Write Control Register 0 (MWCR0)

		Bit 7	显示模式设定
			0 : 绘图模式。
			1 : 文字模式。

		Bit 6	文字写入光标/内存写入光标设定
			0 : 设定文字/内存写入光标为不显示。
			1 : 设定文字/内存写入光标为显示。

		Bit 5	文字写入光标/内存写入光标闪烁设定
			0 : 游标不闪烁。
			1 : 游标闪烁。

		Bit 4   NA

		Bit 3-2  绘图模式时的内存写入方向
			00b : 左 -> 右，然后上 -> 下。
			01b : 右 -> 左，然后上 -> 下。
			10b : 上 -> 下，然后左 -> 右。
			11b : 下 -> 上，然后左 -> 右。

		Bit 1 	内存写入光标自动增加功能设定
			0 : 当内存写入时光标位置自动加一。
			1 : 当内存写入时光标位置不会自动加一。

		Bit 0 内存读取光标自动增加功能设定
			0 : 当内存读取时光标位置自动加一。
			1 : 当内存读取时光标位置不会自动加一。
	*/
	RA8875_WriteReg(0x40, 0x01);	/* 选择绘图模式 */


	/* 	REG[41h] Memory Write Control Register1 (MWCR1)
		写入目的位置，选择图层1
	*/
	RA8875_WriteReg(0x41, 0x00);	/* 选择绘图模式, 目的为CGRAM */

	RA8875_SetDispWin(0, 0, s_WinHeight, s_WinWidth);

	RA8875_ClrScr(0x0000);

	RA8875_TouchInit();
}

#if 0
void RA8875_Test()
{
	int x, y;
	int i;

	arch_BackLight_setup(100);
	RA8875_ClrScr(0x0000);
#if 0
	RA8875_SetFrontColor(0xFFFF);
	RA8875_SetTextZoom(0, 2);
	RA8875_DispAscii(100, 60, "Zhejiang HengQiang Technology co.,ltd");
	RA8875_DispAscii(100, 120, "By Xuhailong");
	RA8875_SetTextZoom(0, 0);
	arch_delay_ms(1000);
#endif
#if 0
	for(y = 0; y < 272; y++) {
		for(x = 0; x < 480; x++) {
			RA8875_PutPixel(x, y, x * y);
		}
	}

#endif
#if 0
	for(i = 0; i < 100; i++) {
		arch_BackLight_setup(i);
		arch_delay_ms(100);
	}
	arch_delay_ms(1000);
	RA8875_ClrScr(0x0000);
#endif

#if 0
	//*******************光标功能测试
	RA8875_SetTextCursor(10, 10);
	RA8875_WriteReg(0x40,0xE0);//设置文字模式光标
	RA8875_WriteReg(0x41,0x00);//关闭图形光标
	RA8875_WriteReg(0x44,0x1f);//光标闪烁周期
	RA8875_WriteReg(0x45,0x81);//光标大小
	arch_delay_ms(2000);
	RA8875_WriteReg(0x21,0x00);//复原寄存器
	RA8875_WriteReg(0x40,0x00);//复原寄存器
#endif

#if 0
	//*******************图形光标
	RA8875_WriteReg(0x84,0x00);//光标颜色0设定
	RA8875_WriteReg(0x85,0xff);//光标颜色1设定
	RA8875_WriteReg(0x41,0x08);//CGRAM写入
	RA8875_WriteReg(0x40,0x00);//设置图形模式光标
	RA8875_WriteCmd(0x02);
	for(i=0; i<256; i++)
	{
		RA8875_WriteData(0xa5);
	}
	RA8875_Cursor_Set_Position(150, 180);
	RA8875_WriteReg(0x41,0x80);//图形光标开启
	arch_delay_ms(1000);
	RA8875_WriteReg(0x41,0x00);//关闭图形光标
	arch_delay_ms(1000);
	RA8875_WriteReg(0x41,0x80);//图形光标开启
	arch_delay_ms(1000);
	RA8875_WriteReg(0x41,0x00);//关闭图形光标
#endif

#if 0
	//********部分窗口清屏测试********
	RA8875_WriteReg(0X8E,0X80);//开始清屏(显示窗口)
	RA8875_WaitBusy();

	RA8875_SetDispWin(40,100,150,200);//设置工作窗口大小
	RA8875_SetBackColor(VM_COLOR_RGB(0xFF, 0x00, 0x00));
	RA8875_WriteReg(0X8E,0X40);//设定清屏性质(工作窗口)
	RA8875_WriteReg(0X8E,0XC0);//开始清屏
	RA8875_WaitBusy();

	RA8875_SetDispWin(150,180,271,479);//设置工作窗口大小
	RA8875_SetBackColor(VM_COLOR_RGB(0x00, 0xFF, 0x00));
	RA8875_WriteReg(0X8E,0X40);//设定清屏性质(工作窗口)
	RA8875_WriteReg(0X8E,0XC0);//开始清屏
	RA8875_WaitBusy();
	arch_delay_ms(1000);
#endif

#if 0
	//********内存写入测试********
	RA8875_SetDispWin(150,0,79,229);//设置工作窗口大小
	RA8875_SetCursor(150,0);//内存写入位置
	RA8875_WriteCmd(0x02);//写入寄存器数据
	i=6400;  //80X80点阵数据量
	while(i--)
	{
		RA8875_WriteData(0xff);//黄色
		RA8875_WaitBusy();
		RA8875_WriteData(0xe0);
		RA8875_WaitBusy();
	}
	arch_delay_ms(300);
#endif

	//********几何图案绘图测试********
	RA8875_SetDispWin(0,0,272,480);//设置工作窗口大小
	//RA8875_WaitBusy();
#if 0
	RA8875_DrawEllipse(120,68,100,50, 0x0);//画曲线
	RA8875_SetFrontColor(VM_COLOR_RGB(0xFF, 0xFF, 0x00));//颜色设定
	RA8875_WriteReg(0XA0,0X10);//设定参数
	RA8875_WriteReg(0XA0,0X90);//开始画
	arch_delay_ms(200);
	RA8875_WriteReg(0XA0,0X91);//开始画
	arch_delay_ms(200);
	RA8875_WriteReg(0XA0,0X92);//开始画
	arch_delay_ms(200);
	RA8875_WriteReg(0XA0,0X93);//开始画
	arch_delay_ms(200);

	RA8875_DrawEllipse(120,168,100,50, 0x0);//画椭圆
	RA8875_SetFrontColor(VM_COLOR_RGB(0xFF, 0x00, 0xF0));//颜色设定
	RA8875_WriteReg(0XA0,0X00);//设定参数
	RA8875_WriteReg(0XA0,0X80);//开始画
	arch_delay_ms(200);
	RA8875_WriteReg(0XA0,0X40);//设定是否填充
	RA8875_WriteReg(0XA0,0XC0);//开始画
	arch_delay_ms(200);
#endif

#if 0
	RA8875_DrawCircle(360,68,60, VM_COLOR_RGB(0xFF, 0xFF, 0x00), 0x00);//画圆
	arch_delay_ms(200);
	RA8875_DrawCircle(360,98,30, VM_COLOR_RGB(0xFF, 0x0F, 0x0F), 0x80);//画圆
	arch_delay_ms(200);
#endif

#if 0
	RA8875_DrawLine(10,136,110,262, VM_COLOR_RGB(0xFF, 0x00, 0xFF));//画矩形
	RA8875_WriteReg(0X90,0X10);//设定参数
	RA8875_WriteReg(0X90,0X90);//开始画
	arch_delay_ms(200);
	RA8875_WriteReg(0X90,0X30);//设定参数
	RA8875_WriteReg(0X90,0XB0);//开始画
	arch_delay_ms(200);
#endif

#if 0
	RA8875_DrawTriangle(60, 262, 255, 136, 370, 262, VM_COLOR_RGB(0x00, 0xFF, 0x00), 0x00);//画三角形
	arch_delay_ms(200);
	RA8875_DrawTriangle(60, 262, 255, 136, 370, 262, VM_COLOR_RGB(0x00, 0xFF, 0xFF), 0x80);//画三角形
	arch_delay_ms(200);
#endif

#if 0
	RA8875_DrawLine(130,36,240,262, VM_COLOR_RGB(0xF0, 0xFF, 0x00));//画圆角矩形
	RA8875_DrawEllipse(0,0,10,15, 0x0);//设定半径
	RA8875_SetFrontColor(VM_COLOR_RGB(0x00, 0xFF, 0xFF));//颜色设定
	RA8875_WriteReg(0XA0,0X20);//设定是否填充
	RA8875_WriteReg(0XA0,0XA0);//开始画
	arch_delay_ms(200);
	RA8875_WriteReg(0XA0,0X60);//设定是否填充
	RA8875_WriteReg(0XA0,0XE0);//开始画
	arch_delay_ms(200);
#endif

#if 0
	RA8875_DrawLine(10,10,470,262, VM_COLOR_RGB(0x00, 0xFF, 0xF0));//画线段
	RA8875_SetFrontColor(VM_COLOR_RGB(0x00, 0x00, 0xFF));//颜色设定
	RA8875_WriteReg(0X90,0X00);//设定参数
	RA8875_WriteReg(0X90,0X80);//开始画
	arch_delay_ms(200);
#endif

#if 0
	while(1) {
#if 0
		int ret;
		char str[32];
		int arch_touch_get_xy(int *_usX, int *_usY, int mode);
		//ret = RA8875_TouchReadXY(&s_usTouchX, &s_usTouchY);
		ret = arch_touch_get_xy(&s_usTouchX, &s_usTouchY, 0);
		if(ret > 0) {
			sprintf(str, "X = %d, Y = %d   ", s_usTouchX, s_usTouchY);
			RA8875_DispAscii(10, 10, str);
			arch_delay_ms(10);
		}
#endif
		arch_touch_detect();
	}
#endif

}
#else
void RA8875_Test()
{
	RA8875_ClrScr(0x0000);
	RA8875_SetFrontColor(0xFFFF);
	RA8875_SetTextZoom(0, 2);
	RA8875_DispAscii(100, 60, "Zhejiang HengQiang Technology co.,ltd");
	RA8875_DispAscii(100, 120, "By Xuhailong");
	RA8875_SetTextZoom(0, 0);
	arch_delay_ms(1000);
}
#endif

